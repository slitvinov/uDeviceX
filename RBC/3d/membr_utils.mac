load("dimension") $

alias(di,  dimension) $
declare(di, posfun);

declare(membrane_constant, feature);
declare(sk, linear);

/*
(%i1) pred_partition([1, 2, 3, 4, 5], oddp);
(%o1)                         [[1, 3, 5], [2, 4]]
*/
pred_partition(expr, pr):= block([yes: [], no: [], inflag: true], local(pr),
  for e in expr do if pr(e) then push(e, yes) else push(e, no),
  [reverse(yes), reverse(no)]);

safe_op(e) := block([inflag : true],
  if mapatom(e) then false else op(e));

/* take differential operator */
mdiff(e):= block([prederror: true, inflag: true, op: safe_op(e), arg],
  if op="+" or op="[" or op="=" then map(mdiff, e)
  else if op="*"     then mdiff(first(e))*rest(e) + first(e)*mdiff(rest(e))
  else if op='dot    then block([a: first(e), b: second(e)],
    dot(mdiff(a), b) + dot(a, mdiff(b)))
  else if op='cp     then block([a: first(e), b: second(e)],
    cp(mdiff(a), b) + cp(a, mdiff(b)))
                                                         /* diff(a^n) */
  else if op="^"  then block([a: first(e), n: second(e)], a^n*log(a)*mdiff(n)+a^(n-1)*n*mdiff(a))
  else if op='cos then block([a: first(e)],
    -sin(a)*mdiff(a))
  else if op='sin then block([a: first(e)],
    cos(a)*mdiff(a))
  else if op=false and mapatom(e) and featurep(e, membrane_constant) then 0
  else if op=false then diff(e)
  else (printf(true, "(mdiff) I see operator: ~a~%", op),
    error("(mdiff) I am confused, teach me how to 'diff this")));

sdiff(e, [L]):= block([ans, opsubst: true, dotexptsimp: false],
  e  : subst(".", dot, e),
  e  : subst(lambda([A, B], sk(A).B), cp, e),
  ans: apply('diff, cons(e, L)),
  subst(dot, ".", ans));

/* return a list of lists of arguments of function 'f */
args_of(e, f):=block([ans: []], local(f),
  subst( lambda([[L]], push(L, ans), funmake(f , L)), f, e),
  ans);

/* true if e contain function 'f */
funp(f, e):=block([ans: false], local(f),
  subst( lambda([[L]], ans: true, funmake(f , L)), f, e),
  ans);
nfunp(f, e):= not funp(f, e);

/* returns difference of two lists */
ldifference(A, B):= listify(setdifference( setify(A), setify(B)));

resimp(e):=expand(e, 0, 0);

/* make 'dot (dot product) and 'cp (cross product) multiadditive */
load("multiadditive");
declare(cp , multiadditive);
declare(dot, multiadditive);

declare(cp, antisymmetric);
declare(dot,    symmetric);

/* pull constant out of 'dot and 'cp */
matchdeclare(CC, constantp);
matchdeclare(ANY, all);
matchdeclare(XX, lambda([e], not constantp(e)));
block([simp: false],
  tellsimpafter( cp(CC*XX, ANY), CC*cp(XX, ANY)),
  tellsimpafter(dot(CC*XX, ANY), CC*dot(XX, ANY)),
  tellsimpafter( cp(ANY, CC*XX), CC*cp(ANY, XX)),
  tellsimpafter(dot(ANY, CC*XX), CC*dot(ANY, XX)));

/* argument with 'del should be at the end */
matchdeclare([AA, BB, CC], nfunp('del));
matchdeclare(XX,            funp('del));
block([simp: false],
  tellsimp(cp(XX, AA), -cp(AA, XX)),
  tellsimp(dot(AA, cp(BB, XX)),   dot(cp(AA, BB), XX)),
  tellsimp(dot(cp(AA, XX), CC),  -dot(cp(AA, CC), XX)));

/* process dimensions in expression */
mdi (e):= block([res, %mdi_extra_eq%: []],
  res: mdi1(e),
  if listp(res) then append(res, %mdi_extra_eq%)
  else                 cons(res, %mdi_extra_eq%));
mdi1(e):= block([ans, inflag: true,
  op,       ?\*standard\-output\*: ?make\-broadcast\-stream()],
  op: safe_op(e),
  if errcatch(ans: di(e))#[] then ans
  else if op="+"           then (
    push(mdi1(first(e)=second(e)), %mdi_extra_eq%),
    if length(e)=2 then mdi1(second(e)) else mdi1(rest(e)))
  else if op="=" or op="[" then map(mdi1, e)
  else if op='cos or op='sin or op='exp then block([A: first(e)],
    if not constantp(A) then push(mdi1(A)=1, %mdi_extra_eq%),
    1)
  else if op="*" or op="." or op='cp or op='dot then funmake("*", map(mdi1, args(e)))
  else if op="^" then block([inflag: true, A, B],
    A: first(e), B: second(e),
    if not constantp(B) then push(mdi1(B) = 1, %mdi_extra_eq%),
    funmake("^", [mdi1(A), B]))
  else funmake('di, [e])) $

/* solve equation for dimensions */
di_solve(di_eq):= block([dvar],
  dvars: unique(map('first, args_of(di_eq, 'di))),
  dvars: map(lambda([e], funmake('di, [e])), dvars),
  dvars: map('log, dvars),
  mso: block([logexpand: all, so],
    so: linsolve(log(di_eq), dvars),
    map(lambda([e], map('exp, e)), so)),
  mso);

/* set dimensions using solution of `di_solve' */
di_set(mso):=for L in mso do block([v: first(lhs(L)), d: rhs(L)], apply('put, [v, d, 'di]));

/* print info */
who(e):= (printf(true, "~12a :  ~24a : ~40a~%", e , get(e, 'di), get(e, 'de)), 'done)$

/* register units and description of a parameter */
un(e, u, d):= (put(e, u, 'di), put(e, d, 'de)) $

%ndim%: 2;
co[1]: co['x]: 'x;
co[2]: co['y]: 'y;
co[3]: co['z]: 'z;
matchdeclare(V, lambda([e], mapatom(e) and nonscalarp(e)));
defrule(rdevector, V, v2co(V));

v2name(n, i):=if atom(n) then concat(n, i)
else if subvarp(n) then arraymake(concat(part(n, 0), i), args(n)) else error("v2name see a strange name");

v2co(V):=makelist(v2name(V, co[d]), d, 1, %ndim%);
sk_def[2]: lambda([v], [-second(v), first(v)]);

qfloat([L])::=buildq([L: create_list(funmake(":", [v, funmake('float, [v])]), v, L)],
  block(splice(L), 'done));

devector5(e):=apply1(e, rdevector);
devector4(e):=subst(lambda([A, B], dot(sk(A), B)), 'cp,
  devector5(e));
devector3(e):=subst(sk_def[%ndim%], 'sk,
  devector4(e));
devector2(e):=subst(".", 'dot, devector3(e));
devector1(e):=subst(lambda([A, B],
    if listp(A) and listp(B) and length(A)=length(B) then map("=", A, B)
    else if listp(A) and B=0 then create_list(q=0, q, A)
    else funmake("=", [A, B])),
  "=",
  devector2(e));
devector (e):=devector1(e);

plus_p(e) := is(safe_op(e) = "+");
matchdeclare(S, plus_p);
tellsimp(dot(S, A), map( lambda([e], dot(e, A)), S));
tellsimp(dot(A, S), map( lambda([e], dot(A, e)), S));

